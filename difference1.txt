yolo-voc_final.weights
bad.list
C1.png
C2.png
C3.png
C4.png
go.cfg
../../software/darknet/cfg/go.test.cfg



































































../../software/darknet/cfg/tiny-yolo-voc.cfg

40200

40100
../../software/darknet/cfg/voc.data

/home/pjreddie/data/voc/train.txt
/home/pjreddie/data/voc/2007_test.txt

/data/home/microway/Documents/CMS/data/train.txt
/data/home/microway/Documents/CMS/data/2007_test.txt
voc.data.bak
yolo.2.0.cfg
../../software/darknet/cfg/yolo.cfg













500200

120000






















0.57273,

0.738768,0.874946,








yolo-voc.2.0.cfg
../../software/darknet/cfg/yolo-voc.cfg













80200


45000






















1.3221,

1.08,1.19,








.cproject
darknet19_448.conv.23
../../software/darknet/demo.sh

cfg/yolo.cfg
--leak-check=full

detect
./darknet
difference1.txt
../../software/darknet/.git/config

https://github.com/chakpongchung/darknet

https://github.com/pjreddie/darknet.git
and
../../software/darknet/.git/logs/HEAD

git

git
../../software/darknet/.git/logs/refs/heads/master

git

git
../../software/darknet/.git/logs/refs/remotes/origin/HEAD

git

git
pack-26cae1a49682ff7e5acc849246194967297d8378.idx
pack-26cae1a49682ff7e5acc849246194967297d8378.pack
pack-95c17d34c0fc0a265f0b7b7f51e172a17c823d2f.idx
pack-95c17d34c0fc0a265f0b7b7f51e172a17c823d2f.pack
../../software/darknet/.git/packed-refs




../../software/darknet/.git/refs/heads/master




Gray.png
../../software/darknet/Makefile










memleak.txt
murf
activation_kernels.o
blas_kernels.o
col2im_kernels.o
convolutional_kernels.o
crop_layer_kernels.o
dropout_layer_kernels.o
im2col_kernels.o
maxpool_layer_kernels.o
Original.png
predictions.jpg
predictions.png
.project
../../software/darknet/scripts/voc_label.py

1./(size[0])
1./(size[1])
(box[0]
(box[2]

1./size[0]
1./size[1]
(box[0]
(box[2]

not

not


2007_val.txt
2007_val.txt
../../software/darknet/src/activation_layer.c

l,

l,

1,

1,

l,

l,

1,

1,

l,

l,

1,

1,

l,

l,

1,

1,
../../software/darknet/src/activation_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/art.c



*cap);



../../software/darknet/src/avgpool_layer.c

avgpool_layer

avgpool_layer

net.input[in_index];

state.input[in_index];

avgpool_layer

avgpool_layer

l.delta[out_index]

l.delta[out_index]
../../software/darknet/src/avgpool_layer.h

avgpool_layer
avgpool_layer

avgpool_layer
avgpool_layer

l,
l,

l,
l,
../../software/darknet/src/avgpool_layer_kernels.cu

void

void

layer.w,

layer.w,

void

void

layer.w,

layer.w,
../../software/darknet/src/batchnorm_layer.c



=
BATCHNORM;
batch;
l.out_h
l.out_w
l.out_c
calloc(h
calloc(h
w*h*c;
l.inputs;

calloc(c,
calloc(c,
calloc(c,
calloc(c,

=
BATCHNORM;
batch;
layer.out_h
layer.out_w
layer.out_c
calloc(h
calloc(h
w*h*c;
layer.inputs;

calloc(c,
calloc(c,

1;

1;

calloc(c,
calloc(c,

calloc(c,
calloc(c,

calloc(c,
calloc(c,

calloc(c,
calloc(c,

forward_batchnorm_layer;
backward_batchnorm_layer;

forward_batchnorm_layer;
backward_batchnorm_layer;

forward_batchnorm_layer_gpu;
backward_batchnorm_layer_gpu;

cuda_make_array(l.output,
cuda_make_array(l.delta,

forward_batchnorm_layer_gpu;
backward_batchnorm_layer_gpu;

cuda_make_array(l.biases,
cuda_make_array(l.bias_updates,

cuda_make_array(layer.output,
cuda_make_array(layer.delta,

cuda_make_array(l.scales,
cuda_make_array(l.scale_updates,

cuda_make_array(layer.scales,
cuda_make_array(layer.scale_updates,

cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(layer.mean,
cuda_make_array(layer.variance,

cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(layer.mean,
cuda_make_array(layer.variance,

cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(layer.mean,
cuda_make_array(layer.variance,

cuda_make_array(l.output,
cuda_make_array(l.output,



CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,



cuda_make_array(layer.output,
cuda_make_array(layer.output,





delta[index]

delta[index]

l,

l,

BATCHNORM)

BATCHNORM)

1,




l.rolling_mean,
l.mean,
l.rolling_variance,
l.variance,

l.rolling_mean,
l.mean,
l.rolling_variance,
l.variance,

1,

l.batch,

l,

layer


l.rolling_mean;
l.rolling_variance;

l.batch,

BATCHNORM)

BATCHNORM)

l,

l,

BATCHNORM)

BATCHNORM)

1,
{

=
=



















{


l.batch,
l.batch,


l.batch,
l.batch,

l.batch,

l,

layer


l.rolling_mean_gpu;
l.rolling_variance_gpu;


=
=



















1,

l.batch,


BATCHNORM)

BATCHNORM)
../../software/darknet/src/batchnorm_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/blas.c

(diff

(diff

n,


0;
=
fabs(diff);
diff




*input,

*input,

largest)

largest)

=

=

e;

e;

sum;




*input,

b;
0;
0;
b*batch_offset


sum;
../../software/darknet/src/blas.h

n,

*input,
*input,

*input,

N,

n,

*input,

*input,
../../software/darknet/src/blas_kernels.cu

x[index]

x[index]

(x[index]

(x[index]

delta[index]

delta[index]

-.5

-.5




(-1./sqrt(variance[filter]

(-1./sqrt(variance[filter]




-.5

-.5

(-1./sqrt(variance[i]

(-1./sqrt(variance[i]

add_kernel(int

=
N)









void

ALPHA,




(diff

(diff

l1_kernel(int

=
n){
=
abs(diff);
(diff



void

pred,





softmax_device(float

softmax_device(int

=

=

=

=

e;

e;

sum;

sum;

softmax_kernel(float

softmax_kernel(int

=
>=
=
=
b*batch_offset

=
batch)
+

void

void

n,

=
=
offset,
../../software/darknet/src/box.c

*f,

*f)

f[1*stride];
f[2*stride];
f[3*stride];

f[1];
f[2];
f[3];
../../software/darknet/src/box.h

*f,

*f);
../../software/darknet/src/cifar.c





../../software/darknet/src/classifier.c



*cap);



0){

0){

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,

net.outputs,
../../software/darknet/src/coco.c





../../software/darknet/src/connected_layer.c




CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,


l,

l,

=

=





l,

l,

=

=

net.delta;

state.delta;

");

");



");

");



l,

l,

a

a





l,

l,





b

b

net.delta_gpu;

state.delta;
../../software/darknet/src/connected_layer.h

layer,
layer,

layer,
layer,

layer,
layer,

layer,
layer,
../../software/darknet/src/convolutional_kernels.cu

l,

l,

l.binary_input_gpu);
l.binary_input_gpu;

l.binary_input_gpu);
l.binary_input_gpu;









i*l.c*l.h*l.w,

i*l.c*l.h*l.w,

b

b


{
l.batch,



l.batch,

smooth_kernel(float

=
n)

=
w;
=
h;
=
c;
=

=
=

=
m;
0;
0;
=
=
=
=
0
valid




void

=
=
=

=

n,



l,

l,


l.smooth);

l.delta_gpu,

l.delta_gpu,

l.batch,




l.x_gpu,

l.batch,

l.output_gpu,

=

=

=

=





















l.batch*l.c*l.h*l.w,

l.batch*l.c*l.h*l.w,

b

b

i*l.c*l.h*l.w,

i*l.c*l.h*l.w,





c

c

l.h,

l.h,

+

+

*w,

layer,

m,
v,
w,

d,
1,
d,

=
layer.bias_updates_gpu,
layer.bias_updates_gpu,

m,
d,



layer.scale_updates_gpu,
layer.scale_updates_gpu,


l,

=


layer.m_gpu,
layer.v_gpu,


l.m_gpu,
l.bias_m_gpu,

l.scale_m_gpu,


layer.weights_gpu,

layer.weight_updates_gpu,
1,
layer.weight_updates_gpu,

layer.m_gpu,
layer.weight_updates_gpu,

l.weights_gpu,
l.weight_updates_gpu,
l.weight_updates_gpu,

l.bias_updates_gpu,
l.bias_updates_gpu,


l.scale_updates_gpu,
l.scale_updates_gpu,


layer.weights_gpu,
layer.weight_updates_gpu,
layer.weight_updates_gpu,
../../software/darknet/src/convolutional_layer.c


0
l,














convolutional_out_height(l);
convolutional_out_width(l);
l.n;





convolutional_out_height(l);
convolutional_out_width(l);
l.n;


get_workspace_size(layer

l){





CUDNN_DATA_FLOAT,

c*n*size*size;
n;


.02;
0;
0;
=

0;

=

calloc(n,
calloc(n,
calloc(n,
calloc(n,

cuda_make_array(l.bias_m,
cuda_make_array(l.bias_v,
cuda_make_array(l.scale_m,
cuda_make_array(l.scale_v,





data;


=
data;




l,

l,

=
=

=
=

l.binary_input);
l.binary_input;

l.binary_input);
l.binary_input;

=

=

l.h,

l.h,

l.c*l.h*l.w;

l.c*l.h*l.w;


{
l.batch,



l.batch,

l,

l,

=

=


l.batch,


{
l.batch,



=

=

=

=





net.workspace;

state.workspace;

l.h,

l.h,




i);






../../software/darknet/src/convolutional_layer.h

layer,
layer,

layer,
layer,

*w,

convolutional_layer

convolutional_layer

layer,

layer,

l);
../../software/darknet/src/cost_layer.c

"L1")==0)




l,

l,

return;

return;

SECRET_NUM)

SECRET_NUM)

net.truth,
==
net.truth,

state.truth,

net.truth,

state.truth,

cost_layer

cost_layer

l.delta,

l.delta,

l,

l,

return;

net.truth_gpu,
*


return;

SECRET_NUM,

SECRET_NUM,

net.truth_gpu,
if
net.truth_gpu,

state.truth,

net.truth_gpu,

state.truth,


l.delta_gpu,



cost_layer

cost_layer

l.delta_gpu,

l.delta_gpu,
../../software/darknet/src/cost_layer.h

cost_layer
cost_layer

cost_layer
cost_layer

l,
cost_layer

l,
cost_layer
../../software/darknet/src/crnn_layer.c

l,

l,

=
net.train;

=
state.train;

*

*

net.input;

state.input;

+=

+=

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

=

=
state.train;

net.input
=

state.input
=

l,

l,

=

=
state.train;

*

*

net.input_gpu;

state.input;

l.state_gpu;

l.state_gpu;

+=

+=

l.state_gpu;

l.state_gpu;

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

=
net.train;

=
state.train;

l.state_gpu;
self_layer.delta_gpu;

l.state_gpu;
self_layer.delta_gpu;

l.state_gpu;
self_layer.delta_gpu
==

l.state_gpu;
self_layer.delta_gpu
==

net.input_gpu
=
=

state.input
=
=
../../software/darknet/src/crnn_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/crop_layer.c

crop_layer
crop_layer

crop_layer
crop_layer

crop_layer

crop_layer





net.input[index]*scale

state.input[index]*scale
../../software/darknet/src/crop_layer.h

crop_layer

crop_layer

l,

l,
../../software/darknet/src/crop_layer_kernels.cu

void

void

layer.rand_gpu,

layer.rand_gpu,

layer.rand_gpu,

layer.rand_gpu,
../../software/darknet/src/cuda.c

*x_gpu,

=
n);
=




../../software/darknet/src/cuda.h

*x_gpu,
../../software/darknet/src/darknet.c






run_regressor(int

run_lsd(int

=

=

*cfgfile,

-1;
=

0,
l,

0;
net.n);



0,

max);

*cfgfile,

=
=
=

0;
=


0;
=

1.5,
=
=
dx,



prefix,










if


if


if
argv[4],

if
atoi(argv[4]),
../../software/darknet/src/data.c

<

<

1

1)

**paths,

=

0;

"targets",
"targets",
".txt",
".txt",

=
&(y.vals[i][0]));






=


=
=

=
=

nh;

1){
scale
nh
{
scale
nw


=
=

=
=

nh,

=
=

=
=
=
=

=
=

=
=

saturation,

=

=
=

=

saturation,


d.y.vals[i],

d.y.vals[i],





if
load_data_regression(a.paths,

if
load_image_color(a.path,
letterbox_image(*(a.im),

**paths,

=
=
0;
load_image_augment_paths(paths,
load_regression_labels_paths(paths,







d.y.vals[index],

d.y.cols*sizeof(float));





d)

=
d.w;
d.h;
0;
d.num_boxes;
d.boxes;
copy_matrix(d.X);
copy_matrix(d.y);

../../software/darknet/src/data.h

CAPTCHA_DATA,

CAPTCHA_DATA,

**paths,

d);
../../software/darknet/src/deconvolutional_kernels.cu



void

void


=
=
=

l.output_gpu,

0;
=
=
=

=
=
=

=
=
=

layer.output_gpu,

0;
=
=
=

l.out_h,

{

{
l.batch,

out_h,

l.activation);

layer.batch,
layer.activation);

void

void

=
=
=
=

l.delta_gpu,
l.activation,

layer.activation,
layer.batch,



{
l.batch,


0,

0,

0;
=
=
=

=
=
=

i*layer.n*size,
0,



=
=
=

=
=
=

0;
=
=
=

=
=
=

i*l.outputs,
l.pad,



=
=
=

=
=
=





void

void

l.c*l.n*l.size*l.size);
l.n);
l.c*l.n*l.size*l.size);
l.n);

l.n);
l.n);
l.n);


layer.c*layer.n*layer.size*layer.size);
layer.n);
layer.c*layer.n*layer.size*layer.size);
layer.n);

void

void

l.c*l.n*l.size*l.size);
l.n);
l.c*l.n*l.size*l.size);
l.n);

l.n);
l.n);
l.n);


layer.c*layer.n*layer.size*layer.size);
layer.n);
layer.c*layer.n*layer.size*layer.size);
layer.n);

l,

void

=

=


l.m_gpu,
l.bias_m_gpu,

l.scale_m_gpu,


l.weights_gpu,
l.weight_updates_gpu,
l.weight_updates_gpu,

l.bias_updates_gpu,
l.bias_updates_gpu,


l.scale_updates_gpu,
l.scale_updates_gpu,



layer.bias_updates_gpu,
layer.bias_updates_gpu,

layer.weights_gpu,
layer.weight_updates_gpu,
layer.weight_updates_gpu,
../../software/darknet/src/deconvolutional_layer.c



l)

=



l)

=



get_workspace_size(layer


l)

*

l)


deconvolutional_out_height(l);
deconvolutional_out_width(l);
l.n;



l)


deconvolutional_out_height(l);
deconvolutional_out_width(l);
l.n;



batch,

batch,

=

=

c*n*size*size;
n;


=

=

0;

scale;

padding;

=
=

(l.h
(l.w

out_h;
out_w;

calloc(l.batch*l.outputs,
calloc(l.batch*l.outputs,

calloc(h*w*size*size*n,
calloc(l.batch*out_h
calloc(l.batch*out_h

batch_normalize;


calloc(n,
calloc(n,
0;
1;


calloc(n,
calloc(n,

calloc(n,
calloc(n,

calloc(n,
calloc(n,
calloc(l.batch*l.outputs,
calloc(l.batch*l.outputs,


1;
calloc(c*n*size*size,
calloc(c*n*size*size,
calloc(n,
calloc(n,
calloc(n,
calloc(n,



forward_deconvolutional_layer_gpu;
backward_deconvolutional_layer_gpu;
update_deconvolutional_layer_gpu;

0){

{
cuda_make_array(l.m,
cuda_make_array(l.v,
cuda_make_array(l.bias_m,
cuda_make_array(l.bias_v,
cuda_make_array(l.scale_m,
cuda_make_array(l.scale_v,

cuda_make_array(l.weights,
cuda_make_array(l.weight_updates,

cuda_make_array(l.biases,
cuda_make_array(l.bias_updates,

cuda_make_array(l.delta,
cuda_make_array(l.output,


cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(l.mean,
cuda_make_array(l.variance,

cuda_make_array(l.scales,
cuda_make_array(l.scale_updates,

cuda_make_array(l.output,
cuda_make_array(l.output,





CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,


cuda_make_array(l.weights,
cuda_make_array(l.weight_updates,

cuda_make_array(l.biases,
cuda_make_array(l.bias_updates,

cuda_make_array(l.col_image,
cuda_make_array(l.delta,
cuda_make_array(l.output,



get_workspace_size(l);

%2d

Layer:

*l,

*l,

(l->h
(l->w

=
=

l->out_h
l->w

realloc(l->output,
realloc(l->delta,

realloc(l->x,
realloc(l->x_norm,




realloc(l->col_image,

realloc(l->output,
out_w
realloc(l->delta,
out_w



cuda_make_array(l->delta,
cuda_make_array(l->output,





cuda_make_array(l->output,
cuda_make_array(l->output,


CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,

cuda_make_array(l->col_image,
cuda_make_array(l->delta,
cuda_make_array(l->output,


get_workspace_size(*l);

layer

deconvolutional_layer

=
=
=

=
=

=
=





l.out_h,

{

{
l.batch,

out_h,

l.activation);

l.batch,
l.activation);

l,

l,

=
=
=
=

l.activation,



{
l.batch,


0,

l.activation,
l.batch,

=
=

=
=

i*l.outputs,
l.pad,


i*l.n*size,
0,






=
=

=
=





l,

l,

l.bias_updates,

l.bias_updates,


l.scale_updates,
l.scale_updates,


l.weights,
l.weight_updates,

l.weights,
l.weight_updates,
../../software/darknet/src/deconvolutional_layer.h

deconvolutional_layer;


l,
l,
l,
l);
l);

layer,
layer,
layer,
layer);
layer);

batch,
*l,
layer
l,
l,

batch,
*layer,
deconvolutional_layer
layer,
layer,

layer);
layer);
layer,

layer);
layer);
../../software/darknet/src/demo.c



*cap);

letterbox_image(in,

resize_image(in,

in.h,

1,
../../software/darknet/src/detection_layer.c

detection_layer

detection_layer

l.outputs*l.batch*sizeof(float));

l.outputs*l.batch*sizeof(float));

index

index





=

=

l.class_scale
l.class_scale
1

l.class_scale
l.class_scale
1

=

=

=

=

*(net.seen)

*(state.net.seen)

=

=

l.coord_scale*(net.truth[tbox_index
l.coord_scale*(net.truth[tbox_index
l.coord_scale*(net.truth[tbox_index
l.coord_scale*(net.truth[tbox_index

l.coord_scale*(state.truth[tbox_index
l.coord_scale*(state.truth[tbox_index
l.coord_scale*(state.truth[tbox_index
l.coord_scale*(state.truth[tbox_index

l.coord_scale*(sqrt(net.truth[tbox_index
l.coord_scale*(sqrt(net.truth[tbox_index

l.coord_scale*(sqrt(state.truth[tbox_index
l.coord_scale*(sqrt(state.truth[tbox_index

detection_layer

detection_layer

l.delta,

l.delta,

detection_layer

detection_layer


1,


1,





=
calloc(num_truth,
num_truth);

l.batch*l.inputs);
=
state.train;
truth_cpu;
in_cpu;





l,

l,

l.delta_gpu,
1,

l.delta_gpu,
1,
../../software/darknet/src/detection_layer.h

detection_layer
detection_layer

detection_layer
detection_layer

detection_layer
l,

detection_layer
l,
../../software/darknet/src/detector.c








0;
=

%f




0;
=

0;
=
%f
1,








0;
=

%f

=

0;
=
%d
8,




=
=
=
=

=
=
=
=

<
<

<
<

*datacfg,


=
=
=
=
=
=
=
map

=




Rate:


=
=

=
=


=
=
=
=
=

=
"%s/%s.json",
fopen(buff,

1;
if(0==strcmp(type,
=
"%s/%s.txt",
fopen(buff,
1;
200;
{
=
calloc(classes,
0;
"%s/%s%s.txt",
fopen(buff,




=
=
0;

=



=
=

=
=
=
=
=
=

=

=
net.w;
net.h;
IMAGE_DATA;
LETTERBOX_DATA;

0;
paths[i+t];
&buf[t];
&buf_resized[t];
load_data_in_thread(args);

=
nthreads;
i);
0;

buf[t];
buf_resized[t];

0;
paths[i+t];
&buf[t];
&buf_resized[t];
load_data_in_thread(args);

0;
=
=
1,

1,


=
=
h,
do_nms_sort(boxes,

boxes,
if
boxes,
{
boxes,






0;



SEEK_CUR);



Detection




IMAGE_DATA;
LETTERBOX_DATA;

IMAGE_DATA;

h,

h,

1,

1,

*datacfg,

*datacfg,

=
=
=
=
sized.h);

=

1,

1,

thresh,












thresh,








test_detector(datacfg,

test_detector(datacfg,

"valid2"))
../../software/darknet/src/dropout_layer.c

l,

l,

return;

return;

l.probability)
*=

l.probability)
*=

l,

l,





l.probability)
*=

l.probability)
*=
../../software/darknet/src/dropout_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/dropout_layer_kernels.cu

layer,

layer,

return;

return;

size,

size,

layer,

layer,





size,

size,
../../software/darknet/src/go.c









int

int

m,

m,

=
make_matrix(n,
make_matrix(n,

19*19*n*sizeof(float));

=
=

19
1;
{
19*row]

19*row])


19*(row

19*(row

=
=

=
=



*cfgfile,

*cfgfile,






=


=
0;




load_network(cfgfile,
ngpus;

=



=

=

=
=
=

N);

=
seconds\n",


=

1){
train_network(net,
{
train_networks(nets,


train_network(net,




move,
=

0){

0){

*stream,

*board,

=
=



0)
==
==
==
==


0)
==
==
==
==


1,

1,

output,

output,

move,

move,

=
0;
{
0;















nind,

nind,

0;
<

0;
0;
+


=

=

=

=

nind,

nind,

player,

indexes);

==

player,

row,


player,
max;

==

index/19,

*cfgfile,

*cfgfile,

=
m
=

=
=

*board,

j;
=
6.5\n");
19\n");

0;
0;
i]
i]
i])






if
=

ids);

Want

ids);

||
||
||

ids);

ids);

19*19*sizeof(float));

if
=

=

0;
1;


if
ids);
1,

if

if



color);
{

buff[0];


color);

'p'

'p'

1,
if
=



(color[0]
if
1;
{
-1;


0);
if


=

=

=

0);

0);



=
final_status_list

j;
=
19\n");

0;
0;
i]
i]
i])


dead\n");

=

=

=
1,

move,


=
1;

4)

=
=

4)


output,

4)


move,

0;
=


nind,
color,

nind,
indexes);

19){
%.2f%%\n",
{
%d,


%d,

19){
row,


col]

==

==



=

j;
=
6.5\n");
19\n");

0;
0;
i]
i]
i])









||

=



=



1,

0);

=

=

=
=
=
=


=
1;

0;
==

calloc(ngpus,
0;
atoi(gpu_list);
strchr(gpu_list,

{
gpu_index;
&gpu;
1;

=


train_go(cfg,
"valid"))

train_go(cfg,
"valid"))
../../software/darknet/src/gru_layer.c


CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,
CUDNN_DATA_FLOAT,



l,

l,

=
net.train;

=
state.train;





net.input;

state.input;

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

l,

l,

=
net.train;

=
state.train;





l.state_gpu;

l.state_gpu;

net.input_gpu;

state.input;

l.forgot_state_gpu;

l.forgot_state_gpu;

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

=
net.train;

=
state.train;

l.inputs*l.batch*(l.steps-1);
+=

l.inputs*l.batch*(l.steps-1);
+=

l.forgot_state_gpu;
l.forgot_delta_gpu;

l.forgot_state_gpu;
l.forgot_delta_gpu;

l.prev_state_gpu;
prev_delta_gpu;

l.prev_state_gpu;
prev_delta_gpu;

net.input_gpu;
net.delta_gpu;

state.input;
state.delta;

l.inputs*l.batch;
-=

l.inputs*l.batch;
-=
../../software/darknet/src/gru_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/image.c








source,


=
0;
0;
0;
=
=
0)
=
=
=
dy+y,






im,

y,
0;
0;
0;
=
=
=
+






m,


0;



im,

=
=
<
w;
(im.h
{
h;
(im.w

=
=


0;
(w-new_w)/2,





im)

3);
j;
g,
u,
0;
0;
get_pixel(im,
get_pixel(im,
get_pixel(im,

y
y
y

j,
j,
j,




im)

3);
j;
g,
u,
0;
0;
get_pixel(im,
get_pixel(im,
get_pixel(im,

.299*r
-.14713*r
.615*r

j,
j,
j,





im)

3);
j,
=
0;
0;
=
0;
scale[k]*get_pixel(im,

im.w*j
im.w*j
im.w*j





=

=
../../software/darknet/src/image.h






==








*cap);
src);




im,

m,

source,
im,

im);

im);
im);

im);
../../software/darknet/src/layer.c




../../software/darknet/src/layer.h


network



L1,

SMOOTH

(struct
(struct

(struct
(struct

(struct
(struct

(struct
(struct















col_image;


bias_m;
bias_v;
scale_m;
scale_v;






col_image_gpu;



../../software/darknet/src/local_layer.c

calloc(out_h*out_w*size*size*c,


out_h*out_w*size*size*c;

cuda_make_array(l.col_image,

local_layer

local_layer

=

=

l.pad,

l.pad,

=

=

l,

l,

=

=

l.pad,

l.pad,

=

=





=

=

l.h,

l.h,

local_layer

local_layer

=

=

l.pad,

l.pad,

=

=

l,

l,

=

=

l.pad,

l.pad,

=

=





=

=

l.h,

l.h,
../../software/darknet/src/local_layer.h

layer,
layer,

layer,
layer,

local_layer
layer,

local_layer
layer,
lsd.c
../../software/darknet/src/matrix.c





m)

=
m.rows;
m.cols;
calloc(c.rows,

0;
calloc(c.cols,
1,


../../software/darknet/src/matrix.h

m);
../../software/darknet/src/maxpool_layer.c

maxpool_layer

maxpool_layer

=

=

maxpool_layer

maxpool_layer

l.delta[i];

l.delta[i];
../../software/darknet/src/maxpool_layer.h

maxpool_layer
maxpool_layer

maxpool_layer
maxpool_layer

l,
l,

l,
l,
../../software/darknet/src/maxpool_layer_kernels.cu

void

void

layer.h,

layer.h,

void

void

layer.h,

layer.h,
../../software/darknet/src/network.c




net)

=
net.w;
net.h;
net.w;

net.min_crop;
net.max_crop;
net.angle;
net.aspect;
net.exposure;
net.saturation;
net.hue;



*cfg,

=
weights[0]


=



<

<

calloc(1,


calloc(1,
calloc(1,


net)

net,

net.workspace;

i;

i;

l.batch,


l.output;

l.output;

l.batch,


l.output;



rate*l.learning_rate_scale,

rate,

net)

net)


>=


net.n-1;



net)

sum/count;



net.outputs);

=
=
k);

net)

net,

=

=
=
net.workspace;

=


i;

orig;

original_input;
original_delta;

prev.output;
prev.delta;

prev.output;
prev.delta;

i;


=


net)

net,

0)

0)



1;


=

0;
net;
x;
0;
y;
1;


=

=
=

net.input,
=

X,
=




=
=

i*batch,
=

i*batch,
=







net,



0;
net;
1;
0;
=
=
0;
0;
=
d.X.vals[index];
d.y.vals[index];


get_network_cost(net);






0){



=
net->layers[0].inputs;
out.outputs;
out.outputs;
=
out.output;


calloc(net->inputs*net->batch,
calloc(net->truths*net->batch,



cuda_make_array(net->input,
cuda_make_array(net->truth,



0;

0;


net)


net.n-1;



net)






l.outputs);


k,

=
=
k,

input;
0;
0;
0;





net;
0;
input;
0;
0;
0;

=


=

=

=

=

net)


net.n
COST)

















day...


net)


net.n
COST)




net)




net)




net)




../../software/darknet/src/network.h


















network_state


















net);

net,

net);
net);
net);

get_network_output_gpu_layer(network
get_network_delta_gpu_layer(network
net);
net,
net,

net);

net);
net);

net,
net,

net,

net);

net,

net);
net,
net,
net);
net,
net);

net);

*cfg,
net);
net);

net);
net);

net);
net);
../../software/darknet/src/network_kernels.cu



net)

get_network_output_gpu_layer(network
get_network_delta_gpu_layer(network
get_network_output_gpu(network

net,

net.workspace;

i;

i;


l.output_gpu;
l.output;

l.output_gpu;
l.output;



l.output_gpu;




net)

net,

net.workspace;

=

original_input
original_delta

i;



orig;

original_input;
original_delta;

prev.output;
prev.delta;
prev.output_gpu;
prev.delta_gpu;

prev.output_gpu;
prev.delta_gpu;

i;




rate*l.learning_rate_scale,

rate,

net)

net,



0;
=
0,
0,
0,



0;
net;
=
=
=

cuda_make_array(x,
cuda_make_array(y,

x_size);
y_size);

*net.input_gpu;
0;
*net.truth_gpu;
1;



net)

net,


=
=
x_size);
y_size);

1;



=

y);
=

rate*l.learning_rate_scale,

rate,

net)

net,

=
REGION)



net)

=
l.outputs*l.batch);


net.n-1;
i);

net.inputs*net.batch);
0;
0;



=

0;
net;
cuda_make_array(input,
0;
0;
0;

=


../../software/darknet/src/nightmare.c








=


cuda_make_array(delta.data,
net->inputs);

cuda_make_array(im.data,
cuda_make_array(im.data,









im.w*im.h*im.c);

0;

im.w*im.h*im.c);



im.data;
delta.data;


im.data;
delta.data;






=

=

recon.w*recon.h*recon.c);
net.truths);
cuda_make_array(delta.data,


1,
l.output_gpu,


delta.w*delta.h*delta.c);



cuda_make_array(recon.data,
cuda_make_array(delta.data,
cuda_make_array(features,




delta.w*delta.h*delta.c);





recon.data;
delta.data;
features;

recon.data;
delta.data;
features;








argc,


3){
%s



=
=
=

=
=
=
=
=
=
=
=
=

=

=
=


=

=


letterbox_image(im,

=

=
=

=

out_im.w*out_im.h*out_im.c);


resize_image(im,
resize_image(f_im,
f_im.data;


0;
rand_uniform(-.19,



make_random_image(im.w,
make_image(im.w,





0;
");

0;
",


im,
==





=
=
layer,





imbase,

cfgbase,

e,





=

rot;

=
=


resized;




letterbox_image(im,

max_layer;

rand_uniform(-.19,

rand_uniform(-.19,




../../software/darknet/src/normalization_layer.c

layer

layer

=

=

1,

1,

layer

layer

layer.norms,
1,

layer.norms,
1,

layer

layer

=

=

1,

1,

layer

layer

layer.norms_gpu,
1,

layer.norms_gpu,
1,
../../software/darknet/src/normalization_layer.h

layer
layer

layer
layer

layer
layer

layer
layer
../../software/darknet/src/parser.c



"[deconv]")==0
"[deconvolutional]")==0)

*options,

=
=
=

=
=


params.h;
params.w;
params.c;

w
=
=
=
=

=






option_find_float_quiet(options,

=
=

=

=

option_find_int_quiet(options,

option_find_float(options,

option_find_float(options,

option_find_float_quiet(options,

option_find_float(options,

==
parse_deconvolutional(options,

option_find_int_quiet(options,
option_find_int_quiet(options,
option_find_int_quiet(options,

option_find_float_quiet(options,
option_find_float_quiet(options,

=
out.outputs;
out.outputs;
=
out.output;
calloc(net.inputs*net.batch,
calloc(net.truths*net.batch,

out.output_gpu;
cuda_make_array(net.input,
cuda_make_array(net.truth,


get_network_output_size(net);
get_network_output(net);

CONVOLUTIONAL

CONVOLUTIONAL){

*net,

*net,

start;

0;

CONVOLUTIONAL

CONVOLUTIONAL){

0,

net->n);
../../software/darknet/src/parser.h

*net,

*net,
../../software/darknet/src/region_layer.c

n*(classes
l.w;
l.h;
l.c;

*x,

*x,

(i
(j
exp(x[index
exp(x[index

(i
(j
exp(x[index
exp(x[index

truth,

truth,

=

=

0*stride]
1*stride]
2*stride]
3*stride]

0]
1]
2]
3]

*output,

*output,

output[index

output[index

stride*(offset

offset

stride*class]

class]

stride*n]
class)

n]
class)

l,

=
=
+



layer

layer

l.outputs*l.batch*sizeof(float));


=
l.outputs*l.batch*sizeof(float));

size*l.n,


0;
=
index,
entry_index(l,
index,

0;
=
4]






=
=
=
count,
group_size;

=
0;
=
index


=
index,

=
0;
=
index









=

=

=

=

=
=
=
l.noobject_scale
=

=
=
1]
=

=
=
class_index,
.3)
=

=
index,
1]
-

=
=

=
=

=

=

=
l.output[obj_index];
l.noobject_scale

l.output[index
4]

0;

4]

12800){

12800){

l.biases,

l.biases,

=

=

=

=
=

=
=

index;

=
=

=

=
l.output[obj_index];
l.object_scale

l.output[best_index
4]

l.object_scale

4]

=


=

=
class_index,

best_index


size*l.n,


layer

layer



=
=
=
index,

l.delta,


l.delta,

l,

l,





==
=
=
=
=
0;
=
=
=
flip[i2];
swap;
0){
-flip[i1];
-flip[i2];





0;
(l.output[i]



=
0;
0;

=
=
=
get_region_box(predictions,

=
(boxes[index].x
(boxes[index].y
(float)max/w;
(float)max/h;


w;
h;
w;
h;


=
=
=
=
get_region_box(predictions,
w;
h;
w;
h;

=

=

class_index,

class_index,

=
=

=

=

=

=
=

=

REMOVE
(j
(j

layer

layer

1,
n;
=
0;
=
index,
entry_index(l,
index,






1,



l.n*(l.coords


=
index,

l.classes

if
=

index,

l.onlyforward){
l.batch*l.outputs);


(l.softmax){
l.classes

=





num_truth);

num_truth);

l.batch*l.inputs);


l.batch*l.inputs);
=
state.train;
truth_cpu;
in_cpu;









layer

l,

n;
=
0;
=
index,
entry_index(l,
index,


l.delta_gpu,

l.n*(l.coords
../../software/darknet/src/region_layer.h

layer
layer
l,

layer
layer
l,

layer
l,

layer
l,
regressor.c
../../software/darknet/src/reorg_layer.c

batch,

batch,

extra;

flatten;



/%2d


l.out_h
l.inputs



%4d
{
/%2d

=

=

layer

layer



l.outputs*l.batch*sizeof(float));

l.c,

l.c,

if
0;
+

if
l.h,
{
l.h,


l.h,

l.h,

layer

layer



l.outputs*l.batch*sizeof(float));

l.c,

l.c,

if(l.reverse){
l.h,
if
0;
+



l.h,

l.h,

l.h,

l,

l,




l.c,

l.c,

if
0;
+

if
l.h,


l.h,

l.h,

l.h,

l,

l,



l.c,

l.c,

if

0;
+

if(l.reverse){
l.h,
{
l.h,


l.h,

l.h,
../../software/darknet/src/reorg_layer.h

batch,

batch,

layer
layer

layer
layer

l,
l,

l,
l,
../../software/darknet/src/rnn.c






=

=

net.inputs*net.batch);
net.truths*net.batch);
=

=

=

=

=

=

=

=

=

=

=

=
../../software/darknet/src/rnn_layer.c

l,

l,

=
net.train;

=
state.train;

*

*

net.input;

state.input;

+=

+=

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

=
net.train;

=
state.train;

net.input
=

state.input
=

l,

l,

=
net.train;

=
state.train;

*

*

net.input_gpu;

state.input;

l.state_gpu;

l.state_gpu;

+=

+=

l.state_gpu;

l.state_gpu;

l.inputs*l.batch;

l.inputs*l.batch;

l,

l,

=
net.train;

=
state.train;

l.state_gpu;
self_layer.delta_gpu;

l.state_gpu;
self_layer.delta_gpu;

l.state_gpu;
self_layer.delta_gpu
==

l.state_gpu;
self_layer.delta_gpu
==

net.input_gpu
=
=

state.input
=
=
../../software/darknet/src/rnn_layer.h

l,
l,

l,
l,

l,
l,

l,
l,
../../software/darknet/src/rnn_vid.c



net.inputs*net.batch);
net.truths*net.batch);
=

=
../../software/darknet/src/route_layer.c

route_layer

route_layer

=

=

route_layer

route_layer

=

=

route_layer

route_layer

=

=

route_layer

route_layer

=

=
../../software/darknet/src/route_layer.h

route_layer
route_layer

route_layer
route_layer

route_layer
route_layer

route_layer
route_layer
../../software/darknet/src/shortcut_layer.c

layer

layer

1,
l.h,

1,
l.h,

layer

layer

l.delta,
l.out_h,

l.delta,
l.out_h,

layer

layer

1,
l.h,

1,
l.h,

layer

layer

l.delta_gpu,
l.out_h,

l.delta_gpu,
l.out_h,
../../software/darknet/src/shortcut_layer.h

layer
layer

layer
layer

layer
layer

layer
layer
../../software/darknet/src/softmax_layer.c

softmax_layer

*input,




0;

=
=
count,

0;
=
count,




softmax_layer


=
=

inputs,

l.batch,

0;
l.temperature,


softmax_layer

softmax_layer

l.delta,


0;
l.delta[i];


softmax_layer

softmax_layer

=
=

count,

inputs,

l.batch,

inputs,

softmax_layer

softmax_layer

layer.delta_gpu,

layer.delta_gpu,
../../software/darknet/src/softmax_layer.h

softmax_layer
softmax_layer

softmax_layer
softmax_layer

softmax_layer
softmax_layer

softmax_layer
softmax_layer
../../software/darknet/src/super.c

*cfgfile,





*cfgfile,

=

=
train_super(cfg,

train_super(cfg,
../../software/darknet/src/swag.c





../../software/darknet/src/tag.c





../../software/darknet/src/tree.c

*x,

*x,

p

p

*predictions,

*predictions,

predictions[parent*stride];

predictions[parent];

=

=

*predictions,

*predictions,

=

=
../../software/darknet/src/tree.h

*predictions,

*predictions,

*predictions,
*x,

*predictions,
*x,
../../software/darknet/src/voxel.c



*cap);


../../software/darknet/src/writing.c





../../software/darknet/src/yolo.c





stderr
stdout
